# 绪论

## 数据结构的基本概念和术语

### 数据、数据元素、数据项和数据对象

**数据**（Data）是客观事物的符号表示，是所有能输入计算机中并被计算机程序处理得到符号的总称。

**数据元素**（Data Element）是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。在有些情况下数据元素也称为元素、记录等。数据元素用于完整地描述一个对象。

**数据项**（Data Item）是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学生基本信息表中的学号、姓名、性别等都是数据项。

**数据对象**（Data Object）是性质相同的数据元素的集合，是数据的一个子集。例如：整数数据对象是集合$$N= \{0, \pm1, \pm2, \pm3, ...\}$$，字符数据对象是集合$$C=\{'A', 'B', 'C',..., 'Z', 'a', 'b', 'c',..., 'z' \}$$。

### 数据结构

**数据结构**（Data Structure）是相互之间存在一种或多种特定关系的数据元素的集合。 另言之，数据结构是带“结构”的数据元素的集合，“结构”就是数据元素之间存在的关系。

数据结构包括逻辑结构和存储结构。

1. **逻辑结构**

数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。另言之，数据的逻辑结构是从具体问题中抽象出来的数学模型。

数据的逻辑结构包含两个要素：一是数据元素；二是关系。数据元素的含义如前所述，关系是指数据元素间的逻辑关系。根据数据元素之间关系的不同特性，数据的逻辑结构通常有4类基本逻辑结构。

- 集合结构
- 线性结构
- 树结构
- 图结构

以某班学生作为数据对象（数据元素是学生的学籍档案记录）为例：

（1）集合结构

数据元素之间除了属于同一集合的关系外，别无其它关系。例如，确定一名学生是否为班级成员，只需将班级看成一个集合结构。

（2）线性结构

数据元素之间存在一对一的关系。例如，将学生信息数据按照其入学报道的时间先后顺序进行排列，将组成一个线性结构。

（3）树结构

数据元素之间存在一对多的关系。例如，在班级的管理体系中，班长管理多个组长，每位组长管理多个组员，从而构成树结构。

（4）图结构

数据元素之间存在多对多的关系。例如，多名同学之间的朋友关系，任何两个同学都可以是朋友，从而构成图结构或网状结构。

其中集合结构、树结构和图结构或网状结构属于非线性结构。

线性结构包括线性表，栈和队列、字符串、数组、广义表。非线性结构包括树结构[分为树（具有多个分支的层次结构）和二叉树（具有两个分支的层次结构）]、图结构[分为有向图（一种图结构、边是顶点的有序对）和无向图（另一种结构，边是顶点的无序对）]和集合结构。


2. **存储结构**

数据对象在计算机中的存储表示称为存储结构，也称为物理结构。把数据对象存储到计算机时，通常要求既要存储各数据元素的数据，又要存储数据元素之间的逻辑关系，数据元素在计算机内用一个节点表示。数据元素在计算机中有两种基本的存储结构，分别是顺序存储结构和链式存储结构。

（1）顺序存储结构

顺序存储结构是借助元素在存储器的相对位置来表示数据元素之间的逻辑关系的，通常借助程序设计语言的数组来描述。

（2）链式存储结构

顺序存储结构要求所有元素依次存放在一片连续的存储空间中，而链式存储结构，无须占用一整块连续的存储空间。但为了表示节点之间的关系，需要给每个节点附加指针字段，用于存放后继元素的存储地址。所以链式存储结构通常借助程序设计语言的指针类型来描述。

### 数据结构类型和抽象数据类型

1. 数据类型

   数据类型是高级程序语言的一个基本概念。

   在程序设计语言中，每一个数据都属于某种数据类型。类型明显或隐含地规定了数据的取值范围、存储方式以及允许进行的运算，数据类型是一个值得集合和定义在这个值集上的一组操作的总称。

2. 抽象数据类型

   抽象是抽取出实际问题的本质。**抽象数据类型**（Abstract Data Type, ADT）一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括3个部分：数据对象、数据对象上关系的集合以及数据对象的基本操作的集合。

   抽象数据类型的定义格式如下：

   ```
   抽象数据类型 {
   	数据对象:<数据对象的定义>
   	数据关系:<数据关系的定义>
   	数据操作:<数据操作的定义>
   }ADT 抽象数据类型名
   ```

   其中，数据对象和数据关系的定义采用数学符号和自然语言描述，基本操作的定义格式为：

   ```
   基本操作名 (参数名)
   	初始条件:<初始条件描述>
   	操作结果:<操作结果描述>
   ```

   基本操作有两种参数：赋值参数只为操作提供输入值；引用参数以&打头，除可提供输入值外，还将返回操作结果。初始条件描述了操作执行之前数据结构和参数应满足的条件，若初始条件为空，则省略。操作结果说明了操作正常完成之后，数据结构的变化状况和相应返回的结果。

## 抽象数据类型的表示与实现

本书采用的类C语言精选了C语言的一个核心子集，同时做了若干扩充和修改，增强了语言的描述功能。

1. 预定义常量以及类型：

   ```c
   #define OK 1
   #define ERROR 0
   #define OVERFLOW -2
   //Status 是返回值类型，其值是函数结果状态代码
   typedef int Status;
   ```

2. 数据结构的表示（存储结构）用类型定义（typedef）描述；数据元素类型约定为ElemType，由用户定义在使用该数据类型时自行定义。

3. 基本操作的算法都用如下格式的函数描述：

   ```c
   函数类型 函数名 (函数参数表)
   {
       //算法说明
       语句序列
   }//函数名
   ```

4. 内存的动态分配与释放。
   使用new和delete动态分配和释放内存空间：

   ```c
   分配空间	指针变量=new数据类型;
   
   释放空间	delete指针变量;
   ```

   

5. 赋值语句：

   ```c
   变量名 = 表达式;									            /* 简单赋值 */ 
   
   变量名1 = 变量名2 = 变量名3 = ... = 变量名n = 表达式;          /* 串联赋值 */
   
   (变量名1, ... , 变量名n) = (表达式1, ... , 表达式n);        /* 成组赋值 */  
   
   结构名1 = 结构名2;								            /* 结构赋值 */
   结构名 = (值1, 值2, ... , 值n);
   
   变量名 = 条件表达式 ? 表达式T : 表达式F;			               /* 条件赋值 */ 
   
   变量名1 <--> 变量名2;								         /* 交换赋值 */ 
   ```

6. 选择语句：

   ```c
   if (表达式) 语句;								            /* 条件语句1 */
    
   if (表达式) 语句;								            /* 条件语句2 */
   else 语句;
   												
   switch (表达式) 						   		         /* 开关语句 */
   		{
       		case 值1: 语句序列1 ; break;
           	case 值2: 语句序列2 ; break;
               ...
           	case 值n: 语句序列n ; break;
           	default: 语句序列n+1;
   		}
   ```

7. 循环语句：

   ```c
   for (表达式1; 条件; 表达式2) 语句;				            /* for语句 */
   
   while (条件) 语句;								            /* while */
   
   do {											            /* do-while语句 */
      语句序列;
   }while (条件);
   ```

8. 结束语句：

   ```c
   //函数结束语句
   return 表达式;
   
   return;
   
   case或循环结束语句 break;
   
   异常结束语句 exit (异常代码);
   ```

9. 输入输出语句使用C++流式输入输出形式：

   ```c
   cin >> 变量1 >> ... >> 变量n;					         /* 输出语句 */
   
   cout << 表达式1 << ... << 表达式n;				         /* 输出语句 */
   ```

10. 基本函数：

   ```c
Max (表达式1, ... , 表达式n);						            /* 求最大值 */

Min (表达式1, ... , 表达式n);						            /* 求最小值 */
   ```
   
## 算法和算法分析



### 算法的定义及特性

算法是为了解决某类问题而规定的一个有限长的操作序列。

算法的5个重要特性：

1. 有穷性。一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。
2. 确定性。对于每种情况下所应执行的操作，在算法中都有确定的规定，不会产生二义性，算法的执行者或阅读者都能明确其含义以及如何执行。
3. 可行性。算法中的所有操作都可以通过将已经实现的基本操作运算执行有限次来实现。
4. 输入。一个算法有0个或多个输入。当用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主函数获得输入值。
5. 输出。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。

### 评价算法优劣的基本标准

1. 正确性。在合理的数据输入下，好的算法能够在有限的运行时间内得到正确的结果。
2. 可读性。一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。
3. 健壮性。当输入的数据非法时，好的算法能适应地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。
4. 高效性。高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂来度量；空间高效是指算法占用内存存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。



### 算法的时间复杂性

衡量算法效率的方法主要有两类：事后统计法和事前分析估算法。事后统计法需要先将算法实现，然后测算其时间和空间开销。这种方法的缺陷很明显，一是必须把算法转成可执行的程序，二是时空开销的测算结果依赖于计算机的软硬件等环境因素，这容易掩盖算法本身的优劣。所以我们通常采用事前分析估算法，通过计算机算法的渐进复杂度来衡量算法的效率。

1. 问题规模和语句频度

不考虑计算机的软硬件等环境因素，影响算法时间代价的最主要因素是问题规模。问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示。

一个算法的执行时间大致上等于其所有语句执行时间总和，而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积。

一条语句的重复次数称作语句频度。由于语句的执行要有源程序经编程序翻译成目标代码，目标代码经装配在执行，因此语句执行一次实际所需的具体时间是与机器的软硬件环境密切相关的。所以，所谓的算法分析并非精确统计算法实际执行所需时间，而是针对算法中语句的执行次数做出估计，从中得到算法执行时间的信息。

设每条语句执行一次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有语句频度之和来估量。

> 例：
>
> 求两个n阶矩阵的乘积算法。
>
> ```c
> for (i = 1; i <= n; i++) {						//频度n+1
>     fot (j = 1; j <= n; j++) {					//频度n*(n+1)
>         c[i][j] = 0;							//频度n^2
>         for (k = 1; k <= n; k++)				//频度n^2 * (n+1)
>         c[i][j] = c[i][j] + a[i][k] + b[k][j];	//频度n^3
>     }
> }
> ```
>
> 该算法中所有语句频度之和，是矩阵阶数n的函数，用f(n)表示之。
> $$
> f(n)=2n^{3}+3n^{2}+2n+1
> $$



2. 算法的时间复杂度定义

为了客观地反应一个算法的执行时间，可以只用算法中的基本语句的执行次数来度量算法的工作量。所谓基本语句指的是算法中重复次数和算法的执行时间成正比的语句，他对算法运行时间的贡献最大。通常，算法的执行时间是随问题规模增长而增长的，因此对算法的评价通常只需考虑其随问题规模增长的趋势。这种情况下，我们只需考虑当问题规模充分大时，算法中基本语句的执行次数在渐进意义下的阶。
$$
\lim_{n\to\infty}{f(n)/n^{3}} = \lim_{n\to\infty}{(2n^{3}+3n^{2}+2n+1)=2}
$$
$f(n)$与是同阶的，或者说$f(n)$和$n^{3}$的数量级相同。我们用“O”来表示数量级，记作$T(n)=O(f(n))=O(n^{3})$。一般情况下，算法中基本语句重复执行的次数是问题规模n的某个函数$f(n)$，算法的时间量度记作：
$$
T(n)=O(f(n))
$$
它表示随着问题规模的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的**渐进时间复杂度**，简称**时间复杂度**。





